#include <stdio.h>
#include <stdlib.h>
#include "../includes/scanner.h"
#include "../includes/parser.h"

int str_equals(const char *a, const char *b){
	while (*a && *b) {

		if(*a != *b) return 0;

		a++;
		b++;
	}

	return *a == *b;
}

void run(char *path){

	int num_of_dir = 0;

	char (*text)[100] = malloc(100 * sizeof *text);
	char (*dirs)[100] = malloc(100 * sizeof *text);

	read_dir(path, &num_of_dir, dirs);

	FILE *out = fopen("out.txt", "w");
	if (!out) {
	
		perror("out.txt");
		return;
	}

	for (int i = 0; i < num_of_dir; i++) {

		char fullpath[256];

		snprintf(fullpath, sizeof(fullpath), "%s/%s", path, dirs[i]);
		
		int ptr = read_file(fullpath, text);
		if(ptr <= 0) continue;
		
		for (int j = 0; j < ptr; j++) {

			fprintf(out, "%s", text[j]);
		
		}

	}
	fclose(out);

	free(text);
	free(dirs);
}
#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include "../includes/scanner.h"

void *read_dir(const char *dir, int *num_of_dir, char (*files)[100]){

	DIR *stack = opendir(dir);

	const struct dirent *File;

	if(!stack){ 
		perror(dir);
		return NULL;
	}
	while ((File = readdir(stack)) != NULL) {

		if (File->d_type == DT_REG) {
			if (File->d_name[0] != '.') {
				snprintf(files[*num_of_dir], 100, "%s", File->d_name);
				(*num_of_dir)++;
			}
		}
	}
	snprintf(files[*num_of_dir], 100, "%s", NULL);
	closedir(stack);

	return NULL;
}
#include <stdio.h>
#include <dirent.h>
#include "../includes/utils.h"
#include "../includes/server.h"

int main(int argc, char **argv){

	// ARRANJAR UMA MANEIRA DE LEMBRAR A ULTIMA POSICAO DO ARRAY
	
	if (argc < 4) {
		printf("Uso: ./program run <dir> <language>\n");
		return 1;
	}

	if (str_equals(argv[1], "run")) {

		run(argv[2]);
		analyze_with_medusa("out.txt", "relatorio.md", "AIzaSyDkcwCPbSP4r8i3S6XLQtLRGQPJjVDwkGQ", argv[3]);

	}

	return 0;
}
#include <stdio.h>
#include "../includes/parser.h"

void print_f(int len, int num, char (*text)[len]){
	for (int i = 0; i < num; i++) {
	
		printf("%s", text[i]);
	}
}

int read_file(char *file, char (*text)[100]){

	int i = 0;

	FILE *f = fopen(file, "r");

	if (!f) return -1;

	while (i < 100 && fgets(*(text + i), 100, f) != NULL) {
		i++;
	}

	fclose(f);
	return i;
}


#include "../includes/server.h"
#include "../includes/parser.h" // contÃ©m read_file
#include "../includes/utils.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <cjson/cJSON.h>

#define BUFFER_SIZE 500000

// --- callback para capturar resposta do curl ---

size_t write_callback(void *ptr, size_t size, size_t nmemb, void *userdata) {
    strncat((char *)userdata, (char *)ptr, size * nmemb);
    return size * nmemb;
}

// --- salva texto em arquivo ---
void write_file(const char *filename, const char *text) {
    FILE *f = fopen(filename, "w");
    if (!f) {
        perror(filename);
        return;
    }
    fputs(text, f);
    fclose(f);
}

// --- envia prompt para Gemini ---
char *send_to_gemini(const char *prompt, const char *api_key) {
    CURL *curl;
    CURLcode res;

    char *response = malloc(BUFFER_SIZE);
    if (!response) return NULL;
    response[0] = '\0';

    curl_global_init(CURL_GLOBAL_ALL);
    curl = curl_easy_init();
    if (!curl) return NULL;

    struct curl_slist *headers = NULL;
    headers = curl_slist_append(headers, "Content-Type: application/json");

    char header_key[256];
    snprintf(header_key, sizeof(header_key), "x-goog-api-key: %s", api_key);
    headers = curl_slist_append(headers, header_key);

    curl_easy_setopt(curl, CURLOPT_URL,
        "https://generativelanguage.googleapis.com/v1beta/models/gemma-3-27b-it:generateContent");
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);

    // Escapa aspas duplas e barras invertidas do prompt
    char *prompt_escaped = malloc(BUFFER_SIZE);
    if (!prompt_escaped) return NULL;
    size_t j = 0;
    for (size_t i = 0; i < strlen(prompt) && j < BUFFER_SIZE-1; i++) {
        if (prompt[i] == '\"') { prompt_escaped[j++] = '\\'; prompt_escaped[j++] = '"'; }
        else if (prompt[i] == '\\') { prompt_escaped[j++] = '\\'; prompt_escaped[j++] = '\\'; }
        else prompt_escaped[j++] = prompt[i];
    }
    prompt_escaped[j] = '\0';

    char json_body[BUFFER_SIZE];
    snprintf(json_body, sizeof(json_body),
        "{ \"contents\": [ { \"parts\": [ {\"text\": \"%s\"} ] } ] }",
        prompt_escaped);

    free(prompt_escaped);

    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_body);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);

    res = curl_easy_perform(curl);
    if (res != CURLE_OK) {
        fprintf(stderr, "Erro curl: %s\n", curl_easy_strerror(res));
        free(response);
        response = NULL;
    }

    curl_slist_free_all(headers);
    curl_easy_cleanup(curl);
    curl_global_cleanup();

    return response;
}

// --- extrai texto limpo do JSON retornado pelo Gemini ---
char *extract_text_from_json(const char *json_text) {
    cJSON *root = cJSON_Parse(json_text);
    if (!root) return NULL;

    cJSON *candidates = cJSON_GetObjectItem(root, "candidates");
    if (!candidates) { cJSON_Delete(root); return NULL; }

    size_t len = 0;
    char *output = malloc(BUFFER_SIZE);
    if (!output) { cJSON_Delete(root); return NULL; }
